\chapter{Medians and Order Statistics}

\section{Minimum and maximum}

\begin{enumerate}

\item[9.1{-}1]{Show that the second smallest of $n$ elements can be found with
$n + \ceil{\lg n} - 2$ comparisons in the worst case. (\emph{Hint:} Also find
the smallest element.)}

\begin{framed}
Lets find first the smallest element. Compare the elements in pairs and discard
the largest element of each pair. The number of elements is now $\ceil{n/2}$.
Repeat this operation recursively to the remaining elements until the smallest
element is found. Since we discard one element in each comparison, the number of
comparisons is the number of elements that is not the smaller.  Thus, $n - 1$
comparisons. Note that the second smallest element can only be greater than the
smallest element. Thus, the second smallest element is among these
$\ceil{\lg n}$ elements that were discarded when compared to the smallest
element. Use the same recursive approach on these $\ceil{\lg n}$ elements to
find the second smallest with $\ceil{\lg n} - 1$ comparisons. The total number
of comparisons in the worst-case is then $n - 1 + \ceil{\lg n}
- 1 = n + \ceil{\lg n} - 2$.
\end{framed}

\item[9.1{-}2]{($\star$) Prove the lower bound of $\ceil{3n/2} - 2$ comparisons
in the worst case to find both the maximum and minimum of $n$ numbers.
(\emph{Hint:} Consider how many numbers are potentially either the maximum or
minimum, and investigate how a comparison affects these counts.)}

\begin{framed}
At the start, any of the $n$ the elements can be both the minimum and the
maximum. After the first comparison, we can discard the largest as not being the
minimum and the smallest as not being the maximum. From now on we have two
options: compare two different elements or compare one of the elements
previously compared with a different element. The first option will decrease by
one both the number of potential minimums and potential maximums, while the
second option will only decrease one these totals. Thus, the best way to start
is to group the elements in pairs and compare them, which requires $\floor{n/2}$
comparisons. After comparing all the pairs, we will have $\ceil{n/2}$ potential
maximums and $\ceil{n/2}$ potential minimums. In the worst-case, those sets are
disjoint and must be treated independently. We know from the previous question
that the minimum number of comparisons needed to find the minimum or the maximum
among $\ceil{n/2}$ elements is $\ceil{n/2} - 1$. Thus, the lower bound to find
both the maximum and the minimum of $n$ numbers is
\[
  \Bigl\lfloor \frac{n}{2} \Bigr\rfloor + 2 \left( \Bigl\lceil \frac{n}{2} \Bigr\rceil - 1 \right).
\]

If $n$ is even, we have
\[
  \Bigl\lfloor \frac{n}{2} \Bigr\rfloor + 2 \left( \Bigl\lceil \frac{n}{2} \Bigr\rceil - 1 \right)
  = \frac{n}{2} + n - 2
  = \frac{3n}{2} - 2
  = \Bigl\lceil \frac{3n}{2} \Bigr\rceil - 2.
\]

If $n$ is odd, we have
\[
  \Bigl\lfloor \frac{n}{2} \Bigr\rfloor + 2 \left( \Bigl\lceil \frac{n}{2} \Bigr\rceil - 1 \right)
  = \frac{n - 1}{2} + (n + 1) - 2
  = \frac{3n - 3}{2}
  = \Bigl\lceil \frac{3n}{2} \Bigr\rceil - 2.
\]
\end{framed}

\end{enumerate}

\newpage

\section{Selection in worst-case linear time}

\begin{enumerate}

\item[9.2-1]{Show that \textsc{Randomized-Select} never makes a recursive call
to a 0-length array.}

\begin{framed}
At the start of each recursive call, a random pivot is chosen. If it happens to
be the $i$th element, the element being searched has been found and is returned
without any additional recursion call. Otherwise, the $i$th element is either
before or after the pivot and a recursive call is made on the side of the
subarray that includes the $i$th element.
\end{framed}

\item[9.2-2]{Argue that the indicator random vartiable $X_k$ and the value
$T(\max(k - 1, n - k))$ are independent.}

\begin{framed}
Both $X_k$ and $T(\max(k - 1, n - k))$ depends on the value of $k$. However, no
matter if $X_k$ is 0 or 1, the value of $T(\max(k - 1, n - k))$ is the same.
\end{framed}

\item[9.2-3]{Write an iterative version of \textsc{Randomized-Select}.}

\begin{framed}
The pseudocode is stated below.

\begin{algorithm}[H]
\SetAlgoNoEnd\DontPrintSemicolon
\BlankLine
\SetKwFunction{algo}{Randomized-Select-Iterative}
\SetKwProg{myalg}{}{}{}
\nonl\myalg{\algo{A, p, r, i}}{%
  \If{$p == r$}{%
    \Return{$A[p]$}\;
  }
  \While{\texttt{\upshape{True}}}{%
    $q = \texttt{Randomized-Partition}(A, p, r)$\;
    $k = q - p + 1$\;
    \If{$i == k$}{%
      \Return{$A[q]$}\;
    }
    \ElseIf{$i < k$}{%
      $r = q - 1$\;
    }
    \Else{%
      $p = q + 1$\;
      $i = i - k$\;
    }
  }
}
\end{algorithm}
\end{framed}

\item[9.2-4]{Suppose we use \textsc{Randomized-Select} to select the minimum
element of the array $A = \langle 3, 2, 9, 0, 7, 5, 4, 8, 6, 1 \rangle$.
Describe a sequence of partitions that results in a worst-case performance of
\textsc{Randomized-Select}.}

\begin{framed}
The worst-case occurs when the pivot is always the greatest element. The number
of calls to partition in this case is $n - 1$.
\end{framed}

\end{enumerate}
