\documentclass{report}

%                       MAIN PACKAGES                       %
% --------------------------------------------------------- %

\usepackage[english]{babel}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{isolatin1}
\usepackage{amssymb}
\usepackage{textcomp}
\usepackage[usenames,dvipsnames]{color}
\usepackage{soul}
\usepackage{cancel}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{framed}
\usepackage{xcolor}
\usepackage{algpseudocode}
\usepackage{algorithm2e} % for psuedo code
\usepackage{courier}
\usepackage{mathtools} % loads amsmath
\usepackage{forest}
\usepackage{tikz}
\usepackage{tikz-qtree}
\usepackage{interval}
\usetikzlibrary{calc}

%                         MARGINS                           %
% --------------------------------------------------------- %

\hoffset=-0.5in
\voffset=-0.6in
\oddsidemargin=0pt
\topmargin=0pt
\headheight=12pt
\headsep=15pt
\textheight=690pt
\textwidth=543pt
\marginparsep=11pt
\marginparwidth=54pt
\footskip=25pt
\marginparpush=5pt
\paperwidth=597pt
\paperheight=845pt

%                        PAGE STYLE                         %
% --------------------------------------------------------- %

\usepackage{fancyhdr}
\pagestyle{fancy}
\lhead{CLRS {--} Chapter 7 {--} Quicksort}
\rhead{Daniel Bastos Moraes}
\cfoot{}
\rfoot{\thepage}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}
\newcommand{\Perp}{\perp\! \! \! \perp}

%                       PROPERTIES                          %
% --------------------------------------------------------- %

\setlength{\parindent}{0cm}

\makeatletter
\renewenvironment{framed}{%
 \def\FrameCommand##1{\hskip\@totalleftmargin
 \fboxsep=\FrameSep\fbox{##1}}%
 \MakeFramed {\advance\hsize-\width
   \@totalleftmargin\z@ \linewidth\hsize
   \@setminipage}}%
 {\par\unskip\endMakeFramed}
\makeatother

\makeatletter
\def\BState{\State\hskip-\ALG@thistlm}
\makeatother

\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}
\DeclareMathOperator{\Exists}{\exists}
\DeclareMathOperator{\Forall}{\forall}

\def\figuredirectory{images}

\mathchardef\mhyphen="2D % Define a "math hyphen"

\tikzset{every tree node/.style={minimum width=1.95em,draw,circle,font=\footnotesize},
         blank/.style={draw=none},
         edge from parent/.style=
         {draw, edge from parent path={(\tikzparentnode) -- (\tikzchildnode)}},
         level distance=1cm}

\DeclareMathOperator{\di}{d\!}
\newcommand*\Eval[3]{\left.#1\right\rvert_{#2}^{#3}}

\intervalconfig{soft open fences}

%                        DOCUMENT                           %
% --------------------------------------------------------- %

\begin{document}

\small

{\large Section 7.1 {--} Description of quicksort}

\begin{enumerate}

\item[7.1{-}1]{Using Figure 7.1 as a model, illustrate the operation of
\textsc{Partition} on the array
$A = \langle 13, 19, 9, 5, 12, 8, 7, 4, 21, 2, 6, 11 \rangle$.}

\begin{framed}
{\centering $ \displaystyle
\definecolor{l}{gray}{0.9}
\definecolor{d}{gray}{0.8}
\definecolor{w}{HTML}{FFFFFF}
\begin{aligned}
  \colorbox{w}{\makebox[1em]{13}} \colorbox{w}{\makebox[1em]{19}} \colorbox{w}{\makebox[1em]{9}}
  \colorbox{w}{\makebox[1em]{5}}  \colorbox{w}{\makebox[1em]{12}} \colorbox{w}{\makebox[1em]{8}}
  \colorbox{w}{\makebox[1em]{7}}  \colorbox{w}{\makebox[1em]{4}}  \colorbox{w}{\makebox[1em]{21}}
  \colorbox{w}{\makebox[1em]{2}}  \colorbox{w}{\makebox[1em]{6}}
  \colorbox{w}{\makebox[1em]{\textcolor{red}{11}}}\\
%
  \colorbox{d}{\makebox[1em]{13}} \colorbox{w}{\makebox[1em]{19}} \colorbox{w}{\makebox[1em]{9}}
  \colorbox{w}{\makebox[1em]{5}}  \colorbox{w}{\makebox[1em]{12}} \colorbox{w}{\makebox[1em]{8}}
  \colorbox{w}{\makebox[1em]{7}}  \colorbox{w}{\makebox[1em]{4}}  \colorbox{w}{\makebox[1em]{21}}
  \colorbox{w}{\makebox[1em]{2}}  \colorbox{w}{\makebox[1em]{6}}
  \colorbox{w}{\makebox[1em]{\textcolor{red}{11}}}\\
%
  \colorbox{d}{\makebox[1em]{13}} \colorbox{d}{\makebox[1em]{19}} \colorbox{w}{\makebox[1em]{9}}
  \colorbox{w}{\makebox[1em]{5}}  \colorbox{w}{\makebox[1em]{12}} \colorbox{w}{\makebox[1em]{8}}
  \colorbox{w}{\makebox[1em]{7}}  \colorbox{w}{\makebox[1em]{4}}  \colorbox{w}{\makebox[1em]{21}}
  \colorbox{w}{\makebox[1em]{2}}  \colorbox{w}{\makebox[1em]{6}}
  \colorbox{w}{\makebox[1em]{\textcolor{red}{11}}}\\
%
  \colorbox{l}{\makebox[1em]{9}} \colorbox{d}{\makebox[1em]{19}} \colorbox{d}{\makebox[1em]{13}}
  \colorbox{w}{\makebox[1em]{5}} \colorbox{w}{\makebox[1em]{12}} \colorbox{w}{\makebox[1em]{8}}
  \colorbox{w}{\makebox[1em]{7}} \colorbox{w}{\makebox[1em]{4}}  \colorbox{w}{\makebox[1em]{21}}
  \colorbox{w}{\makebox[1em]{2}} \colorbox{w}{\makebox[1em]{6}}
  \colorbox{w}{\makebox[1em]{\textcolor{red}{11}}}\\
%
  \colorbox{l}{\makebox[1em]{9}}  \colorbox{l}{\makebox[1em]{5}}  \colorbox{d}{\makebox[1em]{13}}
  \colorbox{d}{\makebox[1em]{19}} \colorbox{w}{\makebox[1em]{12}} \colorbox{w}{\makebox[1em]{8}}
  \colorbox{w}{\makebox[1em]{7}}  \colorbox{w}{\makebox[1em]{4}}  \colorbox{w}{\makebox[1em]{21}}
  \colorbox{w}{\makebox[1em]{2}}  \colorbox{w}{\makebox[1em]{6}}
  \colorbox{w}{\makebox[1em]{\textcolor{red}{11}}}\\
%
  \colorbox{l}{\makebox[1em]{9}}  \colorbox{l}{\makebox[1em]{5}}  \colorbox{d}{\makebox[1em]{13}}
  \colorbox{d}{\makebox[1em]{19}} \colorbox{d}{\makebox[1em]{12}} \colorbox{w}{\makebox[1em]{8}}
  \colorbox{w}{\makebox[1em]{7}}  \colorbox{w}{\makebox[1em]{4}}  \colorbox{w}{\makebox[1em]{21}}
  \colorbox{w}{\makebox[1em]{2}}  \colorbox{w}{\makebox[1em]{6}}
  \colorbox{w}{\makebox[1em]{\textcolor{red}{11}}}\\
%
  \colorbox{l}{\makebox[1em]{9}}  \colorbox{l}{\makebox[1em]{5}}  \colorbox{l}{\makebox[1em]{8}}
  \colorbox{d}{\makebox[1em]{19}} \colorbox{d}{\makebox[1em]{12}} \colorbox{d}{\makebox[1em]{13}}
  \colorbox{w}{\makebox[1em]{7}}  \colorbox{w}{\makebox[1em]{4}}  \colorbox{w}{\makebox[1em]{21}}
  \colorbox{w}{\makebox[1em]{2}}  \colorbox{w}{\makebox[1em]{6}}
  \colorbox{w}{\makebox[1em]{\textcolor{red}{11}}}\\
%
  \colorbox{l}{\makebox[1em]{9}}  \colorbox{l}{\makebox[1em]{5}}  \colorbox{l}{\makebox[1em]{8}}
  \colorbox{l}{\makebox[1em]{7}}  \colorbox{d}{\makebox[1em]{12}} \colorbox{d}{\makebox[1em]{13}}
  \colorbox{d}{\makebox[1em]{19}} \colorbox{w}{\makebox[1em]{4}}  \colorbox{w}{\makebox[1em]{21}}
  \colorbox{w}{\makebox[1em]{2}}  \colorbox{w}{\makebox[1em]{6}}
  \colorbox{w}{\makebox[1em]{\textcolor{red}{11}}}\\
%
  \colorbox{l}{\makebox[1em]{9}}  \colorbox{l}{\makebox[1em]{5}}  \colorbox{l}{\makebox[1em]{8}}
  \colorbox{l}{\makebox[1em]{7}}  \colorbox{l}{\makebox[1em]{4}}  \colorbox{d}{\makebox[1em]{13}}
  \colorbox{d}{\makebox[1em]{19}} \colorbox{d}{\makebox[1em]{12}} \colorbox{w}{\makebox[1em]{21}}
  \colorbox{w}{\makebox[1em]{2}}  \colorbox{w}{\makebox[1em]{6}}
  \colorbox{w}{\makebox[1em]{\textcolor{red}{11}}}\\
%
  \colorbox{l}{\makebox[1em]{9}}  \colorbox{l}{\makebox[1em]{5}}  \colorbox{l}{\makebox[1em]{8}}
  \colorbox{l}{\makebox[1em]{7}}  \colorbox{l}{\makebox[1em]{4}}  \colorbox{d}{\makebox[1em]{13}}
  \colorbox{d}{\makebox[1em]{19}} \colorbox{d}{\makebox[1em]{12}} \colorbox{d}{\makebox[1em]{21}}
  \colorbox{w}{\makebox[1em]{2}}  \colorbox{w}{\makebox[1em]{6}}
  \colorbox{w}{\makebox[1em]{\textcolor{red}{11}}}\\
%
  \colorbox{l}{\makebox[1em]{9}}  \colorbox{l}{\makebox[1em]{5}}  \colorbox{l}{\makebox[1em]{8}}
  \colorbox{l}{\makebox[1em]{7}}  \colorbox{l}{\makebox[1em]{4}}  \colorbox{l}{\makebox[1em]{2}}
  \colorbox{d}{\makebox[1em]{19}} \colorbox{d}{\makebox[1em]{12}} \colorbox{d}{\makebox[1em]{21}}
  \colorbox{d}{\makebox[1em]{13}} \colorbox{w}{\makebox[1em]{6}}
  \colorbox{w}{\makebox[1em]{\textcolor{red}{11}}}\\
%
  \colorbox{l}{\makebox[1em]{9}}  \colorbox{l}{\makebox[1em]{5}}  \colorbox{l}{\makebox[1em]{8}}
  \colorbox{l}{\makebox[1em]{7}}  \colorbox{l}{\makebox[1em]{4}}  \colorbox{l}{\makebox[1em]{2}}
  \colorbox{l}{\makebox[1em]{6}}  \colorbox{d}{\makebox[1em]{12}} \colorbox{d}{\makebox[1em]{21}}
  \colorbox{d}{\makebox[1em]{13}} \colorbox{d}{\makebox[1em]{19}}
  \colorbox{w}{\makebox[1em]{\textcolor{red}{11}}}\\
%
  \colorbox{l}{\makebox[1em]{9}}  \colorbox{l}{\makebox[1em]{5}}  \colorbox{l}{\makebox[1em]{8}}
  \colorbox{l}{\makebox[1em]{7}}  \colorbox{l}{\makebox[1em]{4}}  \colorbox{l}{\makebox[1em]{2}}
  \colorbox{l}{\makebox[1em]{6}}
  \colorbox{w}{\makebox[1em]{\textcolor{red}{11}}}
  \colorbox{d}{\makebox[1em]{21}} \colorbox{d}{\makebox[1em]{13}} \colorbox{d}{\makebox[1em]{19}}
  \colorbox{d}{\makebox[1em]{12}}\\
\end{aligned} $ \par} % Necessary for centering to work
\end{framed}

\item[7.1{-}2]{What value of $q$ does \textsc{Partition} return when all
elements in the array $A=[p, \dots, r]$ have the same value? Modify
\textsc{Partition} so that $q = \floor{(p + r) / 2}$ when all elements in the
array $A[p, \dots, r]$ have the same value.}

\begin{framed}
It will return $q = r$. We can update \textsc{Partition} to split elements that
are equal to the pivot on both sides as follows:
\begin{enumerate}
\item Count the number of elements $y$ such that $y = x$ and set this value to $c$;
\item Subtract the final pivot index by $\floor{c/2}$.
\end{enumerate}

The updated pseucode is stated below.

\begin{algorithm}[H]
\SetAlgoNoEnd\DontPrintSemicolon
\BlankLine
\SetKwFunction{algo}{Partition-Improved}
\SetKwProg{myalg}{}{}{}
\myalg{\algo{A, p, r}}{%
\nl $x = A[r]$\;
\nl $i = p - 1$\;
\nl $c = 0$\;
\nl \For{$j = p$ \KwTo $r - 1$}{%
\nl   \If{$A[j] \le x$}{%
\nl     \If{$A[j] == x$}{%
\nl       $c = c + 1$\; }
\nl     $i = i + 1$\;
\nl     \upshape{exchange} $A[i]$ \upshape{with} $A[j]$\; } }
\nl \upshape{exchange} $A[i + 1]$ \upshape{with} $A[r]$\;
\nl \Return{$(i + 1) - \floor{c/2}$}\; }
\end{algorithm}
\end{framed}

\item[7.1{-}3]{Give a brief argument that the running time of \textsc{Partition}
on a subarray of size $n$ if $\Theta(n)$.}

\begin{framed}
The \textbf{for} loop of lines $3{-}6$ iterates $n - 1$ times and each
iteration does a constant amount of work. Thus, it is $O(n)$.
\end{framed}

\item[7.1{-}4]{How would you modify \textsc{Quicksort} to sort into
nonincreasing order?}

\begin{framed}
We just need to update the condition
\[
  A[j] \le x,
\]
to
\[
  A[j] \ge x.
\]
\end{framed}

\end{enumerate}

\newpage

{\large Section 7.2 {--} Performance of quicksort}

\begin{enumerate}

\item[7.2{-}1]{Use the substitution method to prove the recurrence
$T(n) = T(n - 1) + \Theta(n)$ has the solution $T(n) = \Theta(n^2)$, as claimed
at the beginning of Section 7.2.}

\begin{framed}
Our guess is
\[
  T(n) \le cn^2 - dn\;\Forall n \ge n_0,
\]
where $c$, $d$, and $n_0$ are positive constants. Substituting into the
recurrence, yields
\begin{equation*}
\begin{aligned}
  T(n) &\le c(n - 1)^2 - d(n - 1) + en\\
       &= cn^2 - 2cn + c -d(n - 1) + en & \text{($c = 1, d = 2e$)}\\
       &\le cn^2,\\
\end{aligned}
\end{equation*}
where the last step holds as long as $n_0 \ge 2$.
\end{framed}

\item[7.2{-}2]{What is the running time of \textsc{Quicksort} when all elements
of array $A$ have the same value?}

\begin{framed}
As discussed in (7.1-2), when all elements are the same, $q$ will always be
equal to $r$, which gives the worst-case split. Thus, \textsc{Quicksort} as
implemented in Section 7.1, will run in $\Theta(n^2)$ in this case.
\end{framed}

\item[7.2{-}3]{Show that the running time of \textsc{Quicksort} is $\Theta(n^2)$
when the array $A$ contains distinct elements and is sorted in decreasing
order.}

\begin{framed}
The pivot index $q$ will always be $1$, which gives a $0$ to $n - 1$ split.
The recurrence will be $T(n) = T(n - 1) + \Theta(n) = \Theta(n^2)$.
\end{framed}

\item[7.2{-}4]{Banks often record transactions on an account in order of the
times of the transactions, but many people like to receive their bank statements
with checks listed in order by check number. People usually write checks in
order by check number, and merchants usually cash them with reasonable dispatch.
The problem of converting time-of-transaction ordering to check-number ordering
is therefore the problem of sorting almost-sorted input. Argue that the
procedure \textsc{Insertion-Sort} would tend to beat the procedure
\textsc{Quicksort} on this problem.}

\begin{framed}
Lets assume that each item is out of order by no more than $k$ positions. Note
that in the above scenario, $k$ usually can be bounded by a constant. In this
case, \textsc{Insertion-Sort} runs in $O(kn)$ (it will make at most $k$ swaps
for each item of the array), which is close to linear for small $k$. On the
other hand, \emph{most} splits given by the \textsc{Partition} procedure will
be no better than a $k - 1$ to $n - k$ split. Assuming that it always give an
$k - 1$ to $n - k$ split, the recurrence of \textsc{Quicksort} will be
$T(n) = T(k) + T(n - k) + \Theta(n)$, which is close to quadratic for small $k$.
\end{framed}

\item[7.2{-}5]{Suppose that the splits at every level of quicksort are in the
proportion $1 - \alpha$ to $\alpha$, where $0 < \alpha \le 1/2$ is a constant.
Show that the minimum depth of a leaf in the recursion tree is approximately
$- \lg n / \lg \alpha$ and the maximum depth is approximately
$- \lg n / \lg (1 - \alpha)$. (Don't worry about integer round-off.)}

\begin{framed}
Note that
\[
  \alpha \le \frac{1}{2} \le 1 - \alpha,
\]
which implies $\alpha n \le (1 - \alpha) n$. Thus, the minimum depth occurs on
the path from which the problem size is always divided by $1/\alpha$. This depth
is the number of divisions of $n$ by
$(1/\alpha)$ until reaching a value less than of equal to one, which is
\[
  \log_{1/\alpha} n = \frac{\lg n}{\lg (1/\alpha)}
                    = \frac{\lg n}{- \lg \alpha}
                    = - \frac{\lg n}{\lg \alpha}.
\]

The maximum depth occurs on the path from which the problem size is always
divided by $1/(1 - \alpha)$. This depth is the number of divisions of $n$ by
$1/(1 - \alpha)$ until reaching a value less than or equal to one, which is
\[
  \log_{1/(1 - \alpha)} n
  = \frac{\lg n}{\lg (1/(1 - \alpha))}
  = \frac{\lg n}{- \lg (1 - \alpha)} = - \frac{\lg n}{\lg (1 - \alpha)}.
\]

\end{framed}

\newpage

\item[7.2{-}6]{($\star$) Argue that for any constant $0 < \alpha \le 1/2$, the
probability is approximately $1 - 2\alpha$ that on a random input array,
\textsc{Partition} produces a split more balanced than $1 - \alpha$ to $\alpha$.}

\begin{framed}
Note that $\alpha$ denotes the proportion of the smallest split. Since the input
array is random, the possible proportions for the smallest split forms a uniform
probability distribution, such that
\[
  \text{Pr}\left\{\left[0, \frac{1}{2}\right]\right\} = 1.
\]

Thus, the probability of getting a more balanced split is
\begin{equation*}
\begin{aligned}
  \text{Pr}\left\{\interval[open left, scaled]{\alpha}{\frac{1}{2}}\right\}
  &= \text{Pr}\left\{\interval[scaled]{\alpha}{\frac{1}{2}}\right\}\\
  &= \frac{1/2 - \alpha}{1/2 - 0}\\
  &= \frac{1/2}{1/2} - \frac{\alpha}{1/2}\\
  &= 1 - 2 \alpha.
\end{aligned}
\end{equation*}
\end{framed}

\end{enumerate}

\newpage

{\large Section 7.3 {--} A randomized version of quicksort}

\begin{enumerate}

\item[7.3{-}1]{Why do we analyze the expected running time of a randomized
algorithm and not its worst-case running time?}

\begin{framed}
We can analyze the worst-case. However, due to the randomization, it is not very
useful since we can not associate a specific input to a specific running time.
On the other hand, we can calculate the expected running time, which takes into
account all the possible inputs.
\end{framed}

\item[7.3{-}2]{When \textsc{Randomized-Quicksort} runs, how many calls are made
to the random-number generator \textsc{Random} in the worst case? How about in the
best case? Give your answer in terms of $\Theta$-notation.}

\begin{framed}
Every element is selected as a pivot exactly one time and the number of calls
to \textsc{Random} will always be $n$. Thus, both the best-case and the
worst-case takes $\Theta(n)$, where $n$ denotes the number of calls to
\textsc{Random}.
\end{framed}

\end{enumerate}

\newpage

{\large Section 7.4 {--} Analysis of quicksort}

\begin{enumerate}

\item[7.4{-}1]{Show that in the recurrence
\[
  T(n) = \max_{0 \le q \le n - 1}(T(q) + T(n - q - 1)) + \Theta(n),
\]
\[
  T(n) = \Omega(n^2).
\]}

\begin{framed}
We guess that $T(n) \ge cn^2$ for some constant $c$. Substituting into the
recurrence, yields
\begin{equation*}
\begin{aligned}
  T(n) &\ge \max_{0 \le q \le n - 1}(cq^2 + c(n - q - 1)^2) + \Theta(n)\\
       &=   c \cdot \max_{0 \le q \le n - 1}(q^2 + (n - q - 1)^2) + \Theta(n).
\end{aligned}
\end{equation*}

The expression $q^2 + (n - q - 1)^2$ achieves a maximum at $q = 0$ (proof on
(7.4-3)). Thus, we have
\[
  \max_{0 \le q \le n - 1}(q^2 + (n - q - 1)^2) = (n - 1)^2,
\]
which give us the bound
\begin{equation*}
\begin{aligned}
  T(n) &\ge c (n - 1)^2 + \Theta(n)\\
       &=   cn^2 - 2cn + c + \Theta(n)\\
       &=   cn^2 - c(2n - 1) + \Theta(n)\\
       &\ge cn^2,
\end{aligned}
\end{equation*}
since we pick the constant $c$ small enough so that the $\Theta(n)$ term
dominates the $c(2n - 1)$ term, which implies
\[
  T(n) = \Omega(n^2).
\]
\end{framed}

\item[7.4{-}2]{Show that quicksort's best-case running time is $\Omega(n \lg n)$.}

\begin{framed}
Let $T(n)$ be the best-case time of \textsc{Quicksort} on an input of size
$n$. We have the recurrence
\[
  T(n) = \min_{0 \le q \le n - 1}(T(q) + T(n - q - 1)) + \Theta(n).
\]

We guess $T(n) \ge cn \lg n$ for some constant $c$. Substituting into the
recurrence yields
\begin{equation*}
\begin{aligned}
  T(n) &\ge \min_{0 \le q \le n - 1}(cq \lg q + c(n - q - 1) \lg (n - q - 1)) + \Theta(n)\\
       &=   c \cdot \min_{0 \le q \le n - 1}(q \lg q + (n - q - 1) \lg (n - q - 1)) + \Theta(n).
\end{aligned}
\end{equation*}

For simplicify, assume that $n$ is odd. The expression $c q \lg q + (n - q - 1)
\lg (n - q - 1)$ achieves a minimum when
\[
  q = n - q - 1,
\]
which implies
\[
  q = \frac{n - 1}{2}.
\]
Thus, we have
\begin{equation*}
\begin{aligned}
  T(n) &\ge c \left(\frac{n - 1}{2}\right) \lg \left(\frac{n - 1}{2}\right) +
            c\left(n - \frac{n - 1}{2} - 1\right) \lg \left(n - \frac{n - 1}{2} - 1\right) + \Theta(n)\\
       &= c(n - 1) \lg \left(\frac{n - 1}{2}\right) + \Theta(n)\\
       &= c(n - 1) \lg (n - 1) - c(n - 1) + \Theta(n)\\
       &= cn \lg (n - 1) - c \lg (n - 1) - c (n - 1) + \Theta(n)\\
       &\ge cn \lg \left(\frac{n}{2}\right) - c \lg (n - 1) - c(n - 1) + \Theta(n) & \text{($n \ge 2$)}\\
       &= cn \lg n - cn - c \lg (n - 1) - c(n - 1) + \Theta(n)\\
       &= cn \lg n - c (2n + \lg (n - 1) - 1) + \Theta(n)\\
       &\ge cn \lg n,
\end{aligned}
\end{equation*}
since we pick the constant $c$ small enough so that the $\Theta(n)$ term
dominates the $c(2n + \lg (n - 1) - 1)$ term, which implies
\[
  T(n) = \Omega(n \lg n).
\]
\end{framed}

\item[7.4{-}3]{Show that the expression $q^2 + (n - q - 1)^2$ achieves a maximum
over $q = 0, 1, \dots, n - 1$ when $q = 0$ or $q = n - 1$.}

\begin{framed}
Let $f(q) = q^2 + (n - q - 1)^2$. We have
\[
  f'(q) = 2q + 2(n - q - 1) \cdot (-1) = 4q -2n + 2,
\]
and
\[
  f''(q) = 4.
\]

Since the second derivative is positive, $f(q)$ achieves a maximum over $0, 1,
\dots, n - 1$ at either endpoint. But we have
\[
  f(0) = 0^2 + (n - 1)^2 = (n - 1)^2 + (n - (n - 1) - 1)^2 = f(n - 1),
\]
which implies that both endpoints are maximum.
\end{framed}

\item[7.4{-}4]{Show that \textsc{Randomized-Quicksort's} expected running time
is $\Omega(n \lg n)$.}

\begin{framed}
Combining equations $(7.2)$ and $(7.3)$, we get
\begin{equation*}
\begin{aligned}
  \text{E}[X] &=   \sum_{i = 1}^{n - 1} \sum_{j = i + 1}^{n} \frac{2}{j - i + 1}\\
              &=   \sum_{i = 1}^{\floor{n/2}} \sum_{k = 1}^{n - i} \frac{2}{k + 1} +
                   \sum_{i = \floor{n/2} + 1}^{n - 1} \sum_{k = 1}^{n - i} \frac{2}{k + 1}\\
              &\ge \sum_{i = 1}^{\floor{n/2}} \sum_{k = 1}^{n - i} \frac{2}{k + 1}\\
              &\ge \sum_{i = 1}^{\floor{n/2}} \sum_{k = 1}^{n/2} \frac{2}{k + 1}\\
              &\ge \sum_{i = 1}^{\floor{n/2}} \sum_{k = 1}^{n/2} \frac{1}{k} & \text{(since $k \ge 1$)}\\
              &= \Bigl\lfloor \frac{n}{2} \Bigr\rfloor \cdot \left(\lg \left( \frac{n}{2} \right) + O(1) \right) & \text{(approx. of harmonic number)}\\
              &= \Omega(n \lg n).
\end{aligned}
\end{equation*}
\end{framed}

\item[7.4{-}5]{We can improve the running time of quicksort in practice by
taking advantage of the fast running time of insertion sort when its input is
``nearly'' sorted. Upon calling quicksort on a subarray with fewer than
$k$ elements, let it simply return without sorting the subarray. After the
top-level call to quicksort returns, run insertion sort on the entire array
to finish the sorting process. Argue that this sorting algorithm runs in
$O(nk + n \lg(n/k))$ expected time. How should we pick $k$, both in theory and
in practice?}

\begin{framed}
Lets first analyze the modified \textsc{Quicksort}. As in the standard
\textsc{Quicksort}, it is easy to see that the worst-case of this modified
version is still $O(n^2)$. As for the expected time, we can use a similar
argument to the one used on Section 7.2, in which we saw that any split of
constant proportionality on \textsc{Quicksort} yields a recursion tree of
depth $\Theta(\lg n)$. Assume that \textsc{Partition} on this modified
\textsc{Quicksort} always give a 99-to-1 split. The height $h$ of the recursion
tree would be
\[
  \frac{n}{(100/99)^h} = k \rightarrow h = \log_{100/99} \frac{n}{k} \rightarrow h = \Theta\left(\lg \frac{n}{k}\right).
\]
Since each recursion level has cost at most $cn$, the expected total cost of
this modified \textsc{Quicksort} is $O(n \lg \frac{n}{k})$.

As for the cost of the \textsc{Insertion-Sort}, note that the modified
\textsc{Quicksort} will give an array that is composed by sorted subarrays. The
number of sorted subarrays is at most $n/k$. Thus, \textsc{Insertion-Sort} will
take at most $n/k \cdot O(k^2) = O(nk)$. Finally, the cost of the whole
algorithm is $O(nk) + O(n \lg (n/k)) = O(nk + n \lg (n/k))$.

\end{framed}

\newpage

\item[7.4{-}6]{($\star$) Consider modifying the \textsc{Partition} procedure by
randomly picking three elements from array $A$ and partitioning about their
median (the middle value of the three elements). Approximate the probability of
getting at worst an $\alpha$-to-$(1 - \alpha)$ split, as a function of
$\alpha$ in the range $0 < \alpha < 1$.}

\begin{framed}
First assume $0 < \alpha \le 1/2$. There four ways to get a split worse than
$\alpha$-to-$(1 - \alpha)$:
\begin{enumerate}
  \item The index of exactly two elements are smaller than $\alpha n$
  \item The index of exactly two elements are greater than $n - \alpha n$.
  \item The index of all three elements are smaller than $\alpha n$.
  \item The index of all three elements are greater than $n - \alpha n$.
\end{enumerate}
Since we want an approximation, assume that we can repeat the same element. The
probability of cases (a) and (b) is
\[
  \text{Pr}\{(a)\} = \text{Pr}\{(b)\} =
  3 \cdot \left(\frac{\alpha n}{n} \cdot \frac{\alpha n}{n} \cdot
                \frac{(1 - \alpha) n}{n}\right) =
  3 \alpha^2 - 3 \alpha^3,
\]
in which the multiplication on the left is needed since there are
$\binom{3}{1} = 3$ ways to pick one of three elements outside the desired range.
The probability of cases (c) and (d) is
\[
  \text{Pr}\{(c)\} = \text{Pr}\{(d)\} =
  \frac{\alpha n}{n} \cdot \frac{\alpha n}{n} \cdot \frac{\alpha n}{n} =
  \alpha^3.
\]

Thus, the probability of getting a split worse than $\alpha$-to-$(1 - \alpha)$ is
\begin{equation*}
\begin{aligned}
  1 - \text{Pr}\{(a) + (b) + (c) + (d)\}
  &= 1 - \left(\text{Pr}\{(a)\} + \text{Pr}\{(b)\} + \text{Pr}\{(c)\} + \text{Pr}\{(d)\}\right)\\
  &= 1 - \left((3 \alpha^2 - 3 \alpha^3) + (3 \alpha^2 - 3 \alpha^3) + \alpha^3 + \alpha^3\right)\\
  &= 1 - (6 \alpha^2 - 4 \alpha^3)\\
  &= 1 - 6 \alpha^2 + 4 \alpha^3.
\end{aligned}
\end{equation*}

The proof is similar for $1/2 \le \alpha < 1$ and the result is the same.
\end{framed}

\end{enumerate}

\end{document}
